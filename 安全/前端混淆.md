**javascript混淆(ast语法树)**

- 先看看别人怎么做的嘛
	
1、用js的ast工具分析一下，找到所有字面量，然后提出成局部变量进行替换就好了，得到这种效果：

	(function(a, b, c, d, e, f){
	    a[d] = a[b][c](d);
	    a[d][e]=f;
	})(this, 'document', 'getElementById', 'a', 'innerHTML', 'hello world');

这是从破坏可读性的角度做的混淆，除非用相同的方式做替换，否则很难还原代码，而且核心部分需要深入debug才能了解

前端确实没有秘密可言，还原混淆的成本特别低，大多数混淆策略也不过是障眼法而已（比如这个 https://raw.githubusercontent.com/fouber/noop/master/jquery.min.js 我用了一个特殊的Unicode字符来做「混淆」）
处。

2、如果是保护知识产权的角度，脱离混淆的js加密是伪命题，无论怎么加密，如果不加以混淆手段保护，都没有意义。如同传统软件的加壳保护，js混淆给底层的加密算法加了最基本的保障，在js层面来说，混淆和加密一定是相辅相成的

2.1、为什么需要js混淆（为了保护我们的前端代码逻辑）

js的压缩工具，比如 uglify、compressor、clouser。。。它们的工作主要是：

	- 合并多个js文件
	- 去除js代码里面的空格和换行
	- 压缩js里面的变量名
	- 剔除掉注释

然并卵，于是出现了混淆

2.2、如何进行js混淆

- 通过正则替换实现的混淆器
- 通过语法树替换实现的混淆器


主要介绍语法树替换实现的混淆器

- token: 词法单元，也有叫词法记号的，词法分析器的产物，文本流被分割后的最小单位。
- AST: 抽象语法树，语法分析器的产物，是源代码的抽象语法结构的树状表现形式

（1）编译器工作流程：：：当我们读入一段字符串文本（source code），词法分析器会把它拆成一个一个小的单位（token），比如数字1 是一个token, 字符串'abc'是一个token等等。接下来语法分析器会把这些单位组成一颗树状结构（AST），这个树状结构就代表了token们的组成关系。比如 1 + 2 就会展示成一棵加法树，左右子节点分别是token - 1 和token - 2 ，中间token表示加法。编译器根据生成的AST转换到中间代码，最终转换成机器代码

（2）混淆器工作流程：：：编译器需要把源代码编译成中间代码或者机器码，而我们的混淆器输出其实还是js。所以我们从语法分析之后往下的步骤并不需要。想想我们的目标是什么，是修改原有的js代码结构，在这里面这个结构对应的是什么呢？就是AST。任何一段正确的js代码一定可以组成一颗AST，同样，因为AST表示了各个token的逻辑关系，我们也可以通过AST反过来生成一段js代码。所以，你只需要构造出一颗AST，就能生成任何js代码！、

我们上面说了，我们需要生成新的AST结构意味着会生成和源代码不一样的js代码，但是我们的混淆是不能破坏原有代码的执行结果的，所以混淆规则必须保证是在不破坏代码执行结果的情况下，让代码变得更难以阅读。具体的混淆规则各位可以自行根据需求设计，比如拆分字符串、拆分数组，增加废代码等等

市面上JavaScript词法和文法分析器有很多，比如其实v8就是一个，还有mozilla的SpiderMonkey, 知名的esprima等等，我这里要推荐的是uglify，一个基于nodejs的解析器。它具有以下功能：	

- parser，把 JavaScript 代码解析成抽象语法树
- code generator，通过抽象语法树生成代码
- scope analyzer，分析变量定义的工具
- tree walker，遍历树节点
- tree transformer，改变树节点

2.3、混淆的安全性

混淆的目的是保护代码，但是如果因为混淆影响了正常功能就舍本逐末了。
由于混淆后的AST已经和原AST完全不同了，但是混淆后文件的和原文件执行结果必须一样，如何保证既兼顾了混淆强度，又不破坏代码执行呢？高覆盖的测试必不可少



