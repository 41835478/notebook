###运算符
1、加法运算符
- 加法运算符是在运行时决定，到底是执行相加，还是执行连接。也就是说，运算子的不同，导致了不同的语法行为，这种现象称为“重载”（overload）
```
true + true // 2
1 + true // 2
1 + 'a' // "1a"
false + 'a' // "falsea"
//由于从左到右的运算次序，字符串的位置不同会导致不同的结果
'3' + 4 + 5 // "345"
3 + 4 + '5' // "75"
```
1.2、对象的相加
```
var obj = { p: 1 };
obj + 2 // "[object Object]2" 
//自动调用对象的valueOf方法
//对象的valueOf方法总是返回对象自身，这时再自动调用对象的toString方法，将其转为字符串
//对象的toString方法默认返回[object Object]，所以就得到了最前面那个例子的结果
```

```
//如果运算子是一个Date对象的实例，那么会优先执行toString方法
var obj = new Date();
obj.valueOf = function () { return 1 };
obj.toString = function () { return 'hello' };

obj + 2 // "hello2"
```

2、余数运算符
- 运算结果的正负号由第一个运算子的正负号决定
```
-1 % 2 // -1
1 % -2 // 1
```

3、自增（减）运算符
- 自增和自减运算符有一个需要注意的地方，就是放在变量之后，会先返回变量操作前的值，再进行自增/自减操作；放在变量之前，会先进行自增/自减操作，再返回变量操作后的值
```
var x = 1;
var y = 1;
x++ // 1
++y // 2
```

4、数值运算符，负数值运算符
- 数值运算符（+）同样使用加号，但它是一元运算符（只需要一个操作数），而加法运算符是二元运算符（需要两个操作数）
```
//数值运算符的作用在于可以将任何值转为数值（与Number函数的作用相同）。
+true // 1
+[] // 0
+{} // NaN
```

5、指数运算符
- 指数运算符（**）完成指数运算，前一个运算子是底数，后一个运算子是指数
```
2 ** 4 // 16
```

6、赋值运算符
最常见的赋值运算符，当然就是等号（=）

7、比较运算符
比较运算符用于比较两个值的大小，然后返回一个布尔值，表示是否满足指定的条件
JavaScript 一共提供了8个比较运算符
```
< 小于运算符
> 大于运算符
<= 小于或等于运算符
>= 大于或等于运算符
== 相等运算符
=== 严格相等运算符
!= 不相等运算符
!== 严格不相等运算符
```
- 这八个比较运算符分成两类：：相等比较和非相等比较。两者的规则是不一样的，对于非相等的比较，算法是先看两个运算子是否都是字符串，如果是的，就按照字典顺序比较（实际上是比较 Unicode 码点）；否则，将两个运算子都转成数值，再比较数值的大小。

7.1、字符串的比较
字符串按照字典顺序进行比较

7.2、非字符串的比较
（1）原始类型的值
- 两个原始类型的值的比较，除了相等运算符（==）和严格相等运算符（===），其他比较运算符都是先转成数值再比较
```
5 > '4' // true
// 等同于 5 > Number('4')
// 即 5 > 4
true > false // true
// 等同于 Number(true) > Number(false)
// 即 1 > 0
2 > true // true
// 等同于 2 > Number(true)
// 即 2 > 1
	
	//这里有一个特殊情况，即任何值（包括NaN本身）与NaN比较，返回的都是false
	1 > NaN // false
1 <= NaN // false
'1' > NaN // false
'1' <= NaN // false
NaN > NaN // false
NaN <= NaN // false
```
（2）对象
如果运算子是对象，会转为原始类型的值，再进行比较。

- 对象转换成原始类型的值，算法是先调用valueOf方法；如果返回的还是对象，再接着调用toString方法
```
var x = [2];
x > '11' // true
// 等同于 [2].valueOf().toString() > '11'
// 即 '2' > '11'
x.valueOf = function () { return '1' };
x > '11' // false
// 等同于 [2].valueOf() > '11'
// 即 '1' > '11'

	//两个对象之间的比较（什么情况才会有这中操蛋的操作）
	[2] > [1] // true
// 等同于 [2].valueOf().toString() > [1].valueOf().toString()
// 即 '2' > '1'
[2] > [11] // true
// 等同于 [2].valueOf().toString() > [11].valueOf().toString()
// 即 '2' > '11'
{x: 2} >= {x: 1} // true
// 等同于 {x: 2}.valueOf().toString() >= {x: 1}.valueOf().toString()
// 即 '[object Object]' >= '[object Object]'
```
- Date 对象实例用于比较时，是先调用toString方法。如果返回的不是原始类型的值，再接着对返回值调用valueOf方法

8、相等运算符
JavaScript 提供两种相等运算符：==和===

- 它们的区别是相等运算符（==）比较两个值是否相等，严格相等运算符（===）比较它们是否为“同一个值”。如果两个值不是同一类型，严格相等运算符（===）直接返回false，而相等运算符（==）会将它们转换成同一个类型，再用严格相等运算符进行比较

8.1、严格相等
（1）不同类型的值（直接false没话说）
（2）同一类的原始类型值（值相同就返回true）
```
//NaN与任何值都不相等（包括自身）。另外，正0等于负0
NaN === NaN  // false
+0 === -0 // true
```
（3）复合类型值
两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个地址
```
{} === {} // false
[] === [] // false
(function () {} === function () {}) // false
```
- 对于两个对象的比较，严格相等运算符比较的是地址，而大于或小于运算符比较的是值
```
new Date() > new Date() // false
new Date() < new Date() // false
new Date() === new Date() // false
```
（4）undefined 和 null
```
undefined === undefined // true
null === null // true
//由于变量声明后默认值是undefined，因此两个只声明未赋值的变量是相等的
var v1;
var v2;
v1 === v2 // true
```
（5）严格不相等运算符

8.2、相等运算符
相等运算符用来比较相同类型的数据时，与严格相等运算符完全一样。

比较不同类型的数据时，相等运算符会先将数据进行类型转换，然后再用严格相等运算符比较
（1）原始类型值
- 原始类型的数据会转换成***数值类型***再进行比较
```
1 == true // true
// 等同于 1 === Number(true)
0 == false // true
// 等同于 0 === Number(false)
2 == true // false
// 等同于 2 === Number(true)
2 == false // false
// 等同于 2 === Number(false)
'true' == true // false
// 等同于 Number('true') === Number(true)
// 等同于 NaN === 1
'' == 0 // true
// 等同于 Number('') === 0
// 等同于 0 === 0
'' == false  // true
// 等同于 Number('') === Number(false)
// 等同于 0 === 0
'1' == true  // true
// 等同于 Number('1') === Number(true)
// 等同于 1 === 1
'\n  123  \t' == 123 // true
// 因为字符串转为数字时，省略前置和后置的空格
```
（2）对象与原始类型值比较
- 对象（这里指广义的对象，包括数组和函数）与原始类型的值比较时，对象转化成原始类型的值，再进行比较
```
[1] == 1 // true
// 等同于 Number([1]) == 1
[1] == '1' // true
// 等同于 String([1]) == Number('1')
[1] == true // true
// 等同于 Number([1]) == Number(true)
```
（3）undefined 和 null
- undefined和null与其他类型的值比较时，结果都为false，它们互相比较时结果为true
```
false == null // false
false == undefined // false
0 == null // false
0 == undefined // false
undefined == null // true
```
（4）一些例子

```
0 == ''             // true
0 == '0'            // true

2 == true           // false
2 == false          // false

false == 'false'    // false
false == '0'        // true

false == undefined  // false
false == null       // false
null == undefined   // true

' \t\r\n ' == 0     // true
```

9、布尔运算符（四个运算符）
```
//布尔运算符用于将表达式转为布尔值
取反运算符：!
且运算符：&&
或运算符：||
三元运算符：?:
```
9.1、取反运算符
```
//以下六个值取反后为true，其他值都为false
!undefined // true
!null // true
!0 // true
!NaN // true
!"" // true
```
- 如果对一个值连续做两次取反运算，等于将其转为对应的布尔值，与Boolean函数的作用相同
```
!!x
// 等同于
Boolean(x)
```
9.2、且运算符
- 如果第一个运算子的布尔值为true，则返回第二个运算子的值（注意是值，不是布尔值）；如果第一个运算子的布尔值为false，则直接返回第一个运算子的值，且不再对第二个运算子求值。
```
't' && '' // ""
't' && 'f' // "f"
't' && (1 + 2) // 3
'' && 'f' // ""
'' && '' // ""
```
- 取代if结构
```
if (i) {
  doSomething();
}
// 等价于
i && doSomething();
```
- 且运算符可以多个连用，这时返回第一个布尔值为false的表达式的值
```
true && 'foo' && '' && 4 && 'foo' && true // ''
```

9.3、或运算符
- 如果第一个运算子的布尔值为true，则返回第一个运算子的值，且不再对第二个运算子求值；如果第一个运算子的布尔值为false，则返回第二个运算子的值
```
't' || '' // "t"
't' || 'f' // "t"
'' || 'f' // "f"
'' || '' // ""
```
- 同样可以取代if
```
var x = 1;
true || (x = 2) // true
x // 1
```
- 或运算符可以多个连用，这时返回第一个布尔值为true的表达式的值
```
false || 0 || '' || 4 || 'foo' || true //4
```
- 或运算符常用于为一个变量设置默认值

9.4、三元条件运算符（这没什么说的）
